// NOT TO BE PUBLISHED ON GITHUB. DO NOT SHARE LAB SOLUTIONS.
package lab4;

import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;

/** Helper class for the priority queue in Dijkstras algorithm. */
class PQElement {
	int node;
	int distance;

	public PQElement(int node, int dist) {
		this.node = node;
		this.distance = dist;
	}
}

public class Lab4 {
	/**
	 * Computes the shortest distance between start and end in the graph g using
	 * Dijkstra's algorithm. This version handles only graphs with integer edge
	 * distances.
	 * 
	 * @param g     a graph with distance information attached to the edges
	 * @param start start vertex
	 * @param end   end vertex
	 * @return shortest distance between start and end
	 */
	public static int distance(DistanceGraph g, int start, int end) {
		// Comparator för att hålla kön sorterad på avstånd:
		Comparator<PQElement> cmp = Comparator.comparingInt(e -> e.distance);
		PriorityQueue<PQElement> queue = new PriorityQueue<>(cmp);
		queue.add(new PQElement(start, 0));
		// TODO(D2): slutför Dijkstras algoritm för att hitta kortaste avstånd
		// start->end.
		Map<Integer, Integer> map = new HashMap<>();
		map.put(start, 0);
		while (!queue.isEmpty()) {
			PQElement x = queue.poll();
			if (x.node == end) {
				return x.distance;
			} else {
				for (Edge e : g.edges(x.node)) {
					int w = e.destination;
					int newdist = x.distance + e.distance;
					int wdist = map.getOrDefault(w, Integer.MAX_VALUE);
					if (!map.containsKey(w) || newdist < wdist) {
						map.put(w, newdist);
						queue.add(new PQElement(w, newdist));
					}
				}
			}
		}
		return -1;
	}

	/**
	 * Finds a shortest path between start and end in a graph g Dijkstra's
	 * algorithm. The graph can have any distance unit.
	 * 
	 * @param g     a graph with distance information attached to the edges
	 * @param start start vertex
	 * @param end   end vertex
	 * @return a list containing the nodes on the shortest path from start to end
	 */
	public static List<Integer> shortestPath(DistanceGraph g, int start, int end) {
		Comparator<PQElement> cmp = Comparator.comparingInt(e -> e.distance);
		PriorityQueue<PQElement> queue = new PriorityQueue<>(cmp);
		queue.add(new PQElement(start, 0));

		Map<Integer, Integer> distanceMap = new HashMap<>();
		Map<Integer, Integer> predecessorMap = new HashMap<>();

		distanceMap.put(start, 0);

		while (!queue.isEmpty()) {
			PQElement current = queue.poll();
			int currentNode = current.node;

			if (currentNode == end) {
				// Reconstruct the path from end to start
				List<Integer> path = new LinkedList<>();
				while (currentNode != start) {
					path.add(0, currentNode);
					currentNode = predecessorMap.get(currentNode);
				}
				path.add(0, start);
				return path;
			}

			for (Edge e : g.edges(currentNode)) {
				int neighbor = e.destination;
				int newDistance = distanceMap.get(currentNode) + e.distance;

				if (!distanceMap.containsKey(neighbor) || newDistance < distanceMap.get(neighbor)) {
					distanceMap.put(neighbor, newDistance);
					predecessorMap.put(neighbor, currentNode);
					queue.add(new PQElement(neighbor, newDistance));
				}
			}
		}

		// If no path is found
		return Collections.emptyList();
	}
}
