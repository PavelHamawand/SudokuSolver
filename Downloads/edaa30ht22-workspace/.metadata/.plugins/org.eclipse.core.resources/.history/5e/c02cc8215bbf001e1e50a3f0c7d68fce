// NOT TO BE PUBLISHED ON GITHUB. DO NOT SHARE LAB SOLUTIONS.
package lab4;

import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;

/** Helper class for the priority queue in Dijkstras algorithm. */
class PQElement {
	int node;
	int distance;

	public PQElement(int node, int dist) {
		this.node = node;
		this.distance = dist;
	}
}

public class Lab4 {
	/**
	 * Computes the shortest distance between start and end in the graph g using
	 * Dijkstra's algorithm. This version handles only graphs with integer edge
	 * distances.
	 * 
	 * @param g     a graph with distance information attached to the edges
	 * @param start start vertex
	 * @param end   end vertex
	 * @return shortest distance between start and end
	 */
	public static int distance(DistanceGraph g, int start, int end) {
		// Comparator för att hålla kön sorterad på avstånd:
		Comparator<PQElement> cmp = Comparator.comparingInt(e -> e.distance);
		PriorityQueue<PQElement> queue = new PriorityQueue<>(cmp);
		queue.add(new PQElement(start, 0));
		// TODO(D2): slutför Dijkstras algoritm för att hitta kortaste avstånd
		// start->end.
		Map<Integer, Integer> map = new HashMap<>();
		map.put(start, 0);
		while (!queue.isEmpty()) {
			PQElement x = queue.poll();
			if (x.node == end) {
				return x.distance;
			} else {
				for (Edge e : g.edges(x.node)) {
					int w = e.destination;
					int newdist = x.distance + e.distance;
					int wdist = map.getOrDefault(w, Integer.MAX_VALUE);
					if (!map.containsKey(w) || newdist < wdist) {
						map.put(w, newdist);
						queue.add(new PQElement(w, newdist));
					}
				}
			}
		}
		return -1;
	}

	/**
	 * Finds a shortest path between start and end in a graph g Dijkstra's
	 * algorithm. The graph can have any distance unit.
	 * 
	 * @param g     a graph with distance information attached to the edges
	 * @param start start vertex
	 * @param end   end vertex
	 * @return a list containing the nodes on the shortest path from start to end
	 */
	public static List<Integer> shortestPath(DistanceGraph g, int start, int end) {
		Comparator<PQElement> cmp = Comparator.comparingInt(e -> e.distance);
		PriorityQueue<PQElement> queue = new PriorityQueue<>(cmp);
		queue.add(new PQElement(start, 0));
		// Lista för att hålla den kortaste vägen från start till end
	    LinkedList<Integer> answer = new LinkedList<>();
	    // Map för att spåra avstånd från start till varje nod
	    Map<Integer, Integer> map = new HashMap<>();
	    // Map för att spåra föregående nod för varje nod på den kortaste vägen
	    Map<Integer, Integer> preMap = new HashMap<>();
	    // Sätt avståndet till startnoden till 0
	    map.put(start, 0);

	    // Dijkstra's algoritm
	    while (!queue.isEmpty()) {
	        // Hämta noden med kortast avstånd från kön
	        PQElement x = queue.poll();

	        // Om noden är destinationen, rekonstruera vägen och returnera svaret
	        if (x.node == end) {
	            while (x.node != start) {
	                answer.add(0, x.node); // Lägg till noden i början av listan
	                x.node = preMap.get(x.node); // Uppdatera x till föregående nod
	            }
	            answer.add(0, start); // Lägg till startnoden i början av listan
	            return answer;
	        }

	        if (!queue.contains(x)){ // D4
	        // Loopa igenom grannarna till noden
	        for (Edge e : g.edges(x.node)) {
	            int w = e.destination; // Grannnoden
	            int newdist = x.distance + e.distance; // Nytt beräknat avstånd

	            // Hämta aktuellt avstånd till grannnoden (default: max value om noden inte finns i map)
	            int wdist = map.getOrDefault(w, Integer.MAX_VALUE);

	            // Om nytt avstånd är kortare än det aktuella, uppdatera map och preMap
	            if (!map.containsKey(w) || newdist < wdist) {
	                map.put(w, newdist); // Uppdatera avståndet till grannnoden
	                preMap.put(w, x.node); // Uppdatera föregående nod för grannnoden
	                queue.add(new PQElement(w, newdist)); // Lägg till grannnoden i kön
	            }
	        }
	        }
	    }

	    // Om ingen väg hittades, returnera en tom lista
	    return answer;
	}
}
